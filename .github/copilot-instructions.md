# Go 项目开发核心原则

## 核心开发理念

### 1. 测试驱动开发（TDD）是强制要求

**所有功能开发必须遵循 TDD 流程：**

#### Red-Green-Refactor 循环
1. **Red（红）**: 先编写失败的测试
   - 在编写任何生产代码之前，必须先写测试
   - 测试应该清晰描述预期行为
   - 运行测试，确认它失败（证明测试有效）

2. **Green（绿）**: 编写最简代码使测试通过
   - 实现满足测试的最小代码
   - 不要过度设计或添加未测试的功能
   - 运行测试，确认全部通过

3. **Refactor（重构）**: 优化代码质量
   - 重构代码以提高可读性和可维护性
   - 消除重复，改善设计
   - 确保测试仍然通过

#### TDD 实践规则

在编写任何实现代码之前，必须先编写测试用例，然后再实现功能代码。

#### 测试覆盖率要求
- **最低覆盖率**: 80%（强制）
- **目标覆盖率**: 90%+
- **关键路径覆盖率**: 100%（核心业务逻辑）
- 每次提交前必须运行 `go test -cover` 检查覆盖率

### 2. Go 谚语（Go Proverbs）

遵循 Go 社区的核心智慧，这些谚语总结了 Go 语言的设计哲学：

**核心谚语：**
- **简单胜于聪明**: 不要炫技，写清晰易懂的代码
- **清晰胜于简洁**: 宁可多写几行代码，也要保持清晰
- **并发不是并行**: 并发是结构设计，并行是执行方式
- **通道用于编排，互斥锁用于保护**: 选择正确的同步原语
- **接口越小越好**: 单方法接口是 Go 的常态
- **设计架构，命名组件，文档细节**: 自上而下的设计方法
- **文档是给用户的**: 让代码自解释，文档说明如何使用
- **不要只检查错误，优雅地处理它们**: 错误处理是代码逻辑的一部分
- **使零值有用**: 让类型的零值是可用的、安全的
- **空接口没有任何信息**: 避免过度使用 interface{}
- **Gofmt 的风格不是所有人的最爱，但 gofmt 是每个人的最爱**: 统一格式胜过个人偏好
- **复制比依赖更好**: 小量重复优于复杂的抽象
- **系统调用必须始终使用构建标签保护**: 平台相关代码要明确隔离
- **cgo 不是 Go**: 最小化 cgo 使用，它破坏了 Go 的优势
- **不安全包没有保证**: 避免使用 unsafe，除非绝对必要
- **清晰比聪明更重要**: 可读性永远优先

### 3. Effective Go 原则

遵循 Go 官方的最佳实践指南：

**命名规范：**
- **包名**: 简短、小写、单数、无下划线（如 http, json, time）
- **导出标识符**: 大写字母开头表示公开，小写表示私有
- **接口命名**: 单方法接口以 -er 结尾（如 Reader, Writer, Formatter）
- **获取器命名**: 不使用 Get 前缀，直接使用名词（如 owner 而非 GetOwner）
- **驼峰命名**: 使用 MixedCaps 或 mixedCaps，不使用下划线

**代码组织：**
- **按功能组织**: 每个包应该有清晰的职责
- **减少包依赖**: 避免循环依赖，保持依赖图清晰
- **内部包**: 使用 internal/ 目录限制包的可见性
- **init 函数**: 谨慎使用，仅用于必要的初始化

**错误处理：**
- **显式错误检查**: 不要忽略错误，每个错误都要处理
- **错误包装**: 使用 fmt.Errorf 和 %w 提供上下文
- **自定义错误类型**: 对于需要检查的错误，定义专用类型
- **错误即值**: 将错误作为正常的返回值处理

**并发模式：**
- **通道传递所有权**: 通过通道传递数据的所有权，避免共享内存
- **使用 context**: 传递取消信号、截止时间和请求范围的值
- **不要泄漏 goroutine**: 确保每个 goroutine 都能正常退出
- **使用 sync.WaitGroup**: 等待一组 goroutine 完成

### 4. SOLID 原则（Go 实践）

#### S - 单一职责原则（Single Responsibility Principle）
- 每个包、类型、函数只负责一件事
- 修改的理由只有一个
- 将不同职责分离到不同的包和类型中
- Go 中通过小接口和组合实现职责分离

#### O - 开闭原则（Open/Closed Principle）
- 对扩展开放，对修改封闭
- 使用接口和组合实现扩展
- Go 没有继承，通过接口和嵌入实现多态
- 定义小接口，让不同类型实现接口来扩展功能

#### L - 里氏替换原则（Liskov Substitution Principle）
- 接口的实现必须满足接口的契约
- 任何实现了接口的类型都应该可以替换
- 不要在实现中违反接口的预期行为

#### I - 接口隔离原则（Interface Segregation Principle）
- 客户端不应依赖它不使用的接口
- 使用多个小接口而非单一大接口
- Go 推崇单方法接口（如 io.Reader, io.Writer）
- 通过接口组合构建更复杂的抽象

#### D - 依赖倒置原则（Dependency Inversion Principle）
- 依赖接口而非具体类型
- 高层模块不应依赖低层模块的具体实现
- 通过构造函数注入依赖，接受接口类型参数
- "接受接口，返回结构体"是 Go 的常见模式

- **消除重复**: 相同的逻辑不应出现在多个地方
- **抽象提取**: 将重复代码提取为函数或包
- **配置驱动**: 使用配置文件而非硬编码重复的值
- **注意**: Go 谚语说"复制比依赖更好"，小量重复优于过度抽象
- 在 DRY 和简单性之间找到平衡

### 6. YAGNI 原则（You Aren't Gonna Need It）

- **不要过度设计**: 只实现当前需要的功能
- **延迟决策**: 在需要时再添加功能，而非提前预测
- **保持简单**: 避免"万一以后需要"的代码
- Go 强调简单性，不要添加未使用的字段、方法或抽象
- 先让代码工作，再考虑优化和抽象

### 7. 类型安全与接口设计

- **静态类型**: Go 是静态强类型语言，编译时即可发现类型错误
- **接口设计**: 定义小而专注的接口，通常只有 1-3 个方法
- **避免空接口**: interface{} (any) 应该谨慎使用，它丢失了类型信息
- **类型断言**: 使用类型断言时要检查 ok 返回值
- **泛型使用**: Go 1.18+ 支持泛型，但要适度使用，不要过度泛化
- **零值可用**: 设计类型时让零值是有意义且安全的

### 8. 错误处理与防御性编程

- **显式错误处理**: Go 使用返回值而非异常，必须显式检查每个 error
- **错误包装**: 使用 fmt.Errorf("%w", err) 包装错误，保留错误链
- **错误检查**: 使用 errors.Is 和 errors.As 检查和提取错误
- **自定义错误**: 定义有意义的错误类型，携带更多上下文信息
- **验证输入**: 永远不要信任外部输入，在函数入口处验证
- **早返回**: 使用 guard clauses，错误情况早返回，减少嵌套
- **panic 使用**: 仅在不可恢复的错误时使用 panic，库代码不应 panic
- **defer 清理**: 使用 defer 确保资源被正确释放（文件、连接等）

### 9. 并发安全

- **不要通过共享内存通信，通过通信共享内存**: 优先使用 channel 而非共享变量
- **channel 所有权**: 通过 channel 传递数据的所有权，避免并发访问
- **关闭 channel**: 只有发送方应该关闭 channel
- **使用 context**: 传递取消信号、超时和请求范围的值
- **避免 goroutine 泄漏**: 确保每个 goroutine 都有退出路径
- **数据竞争检测**: 使用 go test -race 检测数据竞争
- **互斥锁**: 当必须共享内存时，使用 sync.Mutex 或 sync.RWMutex
- **sync.Once**: 用于保证初始化只执行一次
- **有缓冲 vs 无缓冲**: 理解两种 channel 的区别和使用场景

### 10. 文档与注释

- **包文档**: 每个包都应该有包级别的文档注释
- **导出标识符**: 所有导出的类型、函数、常量都必须有文档注释
- **示例测试**: 使用 Example 测试提供可执行的示例代码
- **godoc 格式**: 文档注释以标识符名称开头，使用完整句子
- **注释风格**: 解释"为什么"而非"是什么"，代码应该自解释
- **TODO 注释**: 使用 TODO(user): 标记待办事项

### 11. 性能与优化

- **先测量再优化**: 使用 pprof 和基准测试找到真正的瓶颈
- **基准测试**: 编写 Benchmark 测试验证优化效果
- **避免过早优化**: 清晰的代码优先，证明有性能问题时再优化
- **内存分配**: 注意减少不必要的堆分配，复用对象（sync.Pool）
- **字符串拼接**: 大量拼接使用 strings.Builder 而非 + 操作符
- **切片预分配**: 如果知道大小，使用 make 预分配 slice 容量

## 代码审查标准

所有代码合并前必须满足：

1. ✅ 所有测试通过（go test ./...）
2. ✅ 测试覆盖率 ≥ 80%（go test -cover ./...）
3. ✅ 无数据竞争（go test -race ./...）
4. ✅ 代码已格式化（gofmt / goimports）
5. ✅ 通过静态检查（go vet）
6. ✅ 通过 linter 检查（golangci-lint）
7. ✅ 所有导出标识符有文档注释
8. ✅ 遵循 TDD 流程（测试先行）
9. ✅ 遵循 Go 谚语和 Effective Go
10. ✅ 错误处理正确且完整
11. ✅ 并发代码安全，无 goroutine 泄漏
12. ✅ 接口设计合理，依赖抽象
13. ✅ 代码简单清晰，无过度设计

## 提交前检查清单

提交代码前需依次执行以下检查：

1. **格式化代码**
   - gofmt -s -w .
   - goimports -w .

2. **运行测试**
   - go test ./...
   - go test -race ./...
   - go test -cover ./...

3. **静态检查**
   - go vet ./...
   - golangci-lint run
   - go mod tidy

4. **构建验证**
   - go build ./...

## Go 项目结构规范

推荐的项目结构（遵循 Go 社区标准）：

```
project/
├── cmd/                    # 主要应用程序入口
│   └── appname/
│       └── main.go
├── internal/               # 私有应用和库代码
│   ├── app/               # 应用逻辑
│   ├── pkg/               # 内部包
│   └── ...
├── pkg/                    # 可被外部使用的库代码
├── api/                    # API 定义（protobuf, OpenAPI）
├── web/                    # Web 应用资源
├── configs/                # 配置文件
├── scripts/                # 构建、安装、分析等脚本
├── test/                   # 额外的外部测试应用和测试数据
├── docs/                   # 设计和用户文档
├── tools/                  # 项目的支持工具
├── vendor/                 # 依赖（可选，使用 go mod vendor）
├── go.mod                  # Go 模块定义
├── go.sum                  # Go 模块校验和
├── Makefile                # 构建脚本
└── README.md               # 项目说明
```

## 违反原则的处理

- **代码审查拒绝**: 不符合原则的代码不能合并
- **重构要求**: 必须按照原则进行重构
- **教育优先**: 帮助团队理解和应用这些原则
- **工具强制**: 使用 CI/CD 自动检查代码质量

## 推荐工具

- **格式化**: gofmt, goimports
- **静态检查**: go vet, staticcheck
- **Linter**: golangci-lint（集成多个 linter）
- **测试**: go test, testify（断言库）
- **Mock**: gomock, mockgen
- **性能分析**: pprof, trace
- **依赖管理**: go mod
- **文档**: godoc

---

**记住**: 这些原则源自 Go 语言的设计哲学和社区实践。Go 强调简单性、清晰性和实用主义。当有疑问时，优先考虑代码的可读性、可维护性和简单性。正如 Rob Pike 所说："清晰比聪明更重要"。